#!/usr/bin/env node

/**
 * Generate deck metadata from HTML files in public/learn/decks/
 * Parses each HTML file to extract title, description, category from meta tags
 * Outputs to lib/deck-data.ts
 */

const fs = require('fs')
const path = require('path')

const DECKS_DIR = path.join(__dirname, '../public/learn/decks')
const OUTPUT_FILE = path.join(__dirname, '../lib/deck-data.ts')

// Category detection based on keywords in title/description
const CATEGORY_PATTERNS = {
  intro: ['what is', 'getting started', 'introduction', 'how amplifier', 'bundles', 'best practices', 'patterns'],
  platform: ['shadow', 'session', 'recipes', 'workflow', 'context', 'modes', 'forking'],
  tool: ['tool', 'database', 'diagrams', 'github actions', 'mcp'],
  showcase: ['case study', 'showcase', 'experiment', 'demo'],
  enterprise: ['enterprise', 'm365', 'microsoft 365', 'cortex', 'sandbox'],
}

function detectCategory(title, description) {
  const text = `${title} ${description}`.toLowerCase()
  
  for (const [category, patterns] of Object.entries(CATEGORY_PATTERNS)) {
    for (const pattern of patterns) {
      if (text.includes(pattern)) {
        return category
      }
    }
  }
  return 'platform' // default
}

function extractMetaContent(html, name) {
  // Try og: tags first, then regular meta
  const ogMatch = html.match(new RegExp(`<meta\\s+property=["']og:${name}["']\\s+content=["']([^"']+)["']`, 'i'))
  if (ogMatch) return ogMatch[1]
  
  const metaMatch = html.match(new RegExp(`<meta\\s+name=["']${name}["']\\s+content=["']([^"']+)["']`, 'i'))
  if (metaMatch) return metaMatch[1]
  
  return null
}

function extractTitle(html) {
  // Try meta title first
  const metaTitle = extractMetaContent(html, 'title')
  if (metaTitle) return metaTitle
  
  // Fall back to <title> tag
  const titleMatch = html.match(/<title>([^<]+)<\/title>/i)
  if (titleMatch) return titleMatch[1].replace(' - Amplifier Stories', '').trim()
  
  // Fall back to first h1
  const h1Match = html.match(/<h1[^>]*>([^<]+)<\/h1>/i)
  if (h1Match) return h1Match[1].trim()
  
  return null
}

function extractDescription(html) {
  const desc = extractMetaContent(html, 'description')
  if (desc) return desc
  
  // Try to find subtitle or first paragraph
  const subtitleMatch = html.match(/<p class="[^"]*subtitle[^"]*">([^<]+)<\/p>/i)
  if (subtitleMatch) return subtitleMatch[1].trim()
  
  return ''
}

function slugToTitle(slug) {
  return slug
    .replace(/-deck$/, '')
    .replace(/-/g, ' ')
    .replace(/\b\w/g, c => c.toUpperCase())
}

function parseDecks() {
  const files = fs.readdirSync(DECKS_DIR)
    .filter(f => f.endsWith('.html') && f !== 'index.html')
    .sort()
  
  const decks = []
  
  for (const file of files) {
    const filePath = path.join(DECKS_DIR, file)
    const html = fs.readFileSync(filePath, 'utf-8')
    const slug = file.replace('.html', '')
    
    const title = extractTitle(html) || slugToTitle(slug)
    const description = extractDescription(html)
    const category = detectCategory(title, description)
    
    decks.push({
      id: slug,
      title,
      description,
      category,
      href: `/learn/decks/${file}`,
    })
  }
  
  return decks
}

function generateTypeScript(decks) {
  const deckEntries = decks.map(d => {
    const desc = d.description.replace(/'/g, "\\'").replace(/\n/g, ' ')
    return `  {
    id: '${d.id}',
    title: '${d.title.replace(/'/g, "\\'")}',
    description: '${desc}',
    category: '${d.category}',
    href: '${d.href}',
  }`
  }).join(',\n')

  return `// Auto-generated by scripts/generate-deck-metadata.js
// Do not edit manually - run: npm run sync-decks

import { Deck } from '@/components/LearnCard'

export const decks: Deck[] = [
${deckEntries}
]

export const lastSynced = '${new Date().toISOString()}'
`
}

// Main
const decks = parseDecks()
const output = generateTypeScript(decks)
fs.writeFileSync(OUTPUT_FILE, output)

console.log(`Generated metadata for ${decks.length} decks`)
console.log(`Output: ${OUTPUT_FILE}`)
